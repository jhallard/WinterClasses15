\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{url}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[margin=0.5in]{geometry}

% \setlength{\voffset}{-0.5in}
\setlength{\headsep}{5pt}
\newcommand{\suchthat}{\;\ifnum\currentgrouptype=16 \middle\fi|\;}
\newcommand{\answer}{\textbf{Answer : }}
\newcommand{\cd}{\texttt}
\newcommand{\benu}{\begin{enumerate}}
\newcommand{\enu}{\end{enumerate}}


%===========---------================
% Author John H Allard
% CMPE 110, HW #1
% December 10th, 2014
%===========---------================

\begin{document}
    % \vspace*{\stretch{-0.5}}
   \begin{center}
      \Large\textbf{CMPE 110 Homework \#1}\\
      \large\texttt{John Allard} \\
      \small\texttt{January 19th, 2015} \\
      \small\texttt{jhallard@ucsc.edu}
   \end{center}
   % \vspace*{\stretch{-0.5}}


\benu

%==============================%
% ======== PROBLEM #1 ======== %
%==============================%
\item Question \#1 - Power \\

\benu

%===============================%
% ======== PROBLEM #1A ======== %
%===============================%
\item Question \#1A : `...However, we discussed that nowadays power density and heat has become an issue preventing scaling of frequency. Discuss why power and temperature are becoming an issue'. \\
\answer  \\


%===============================%
% ======== PROBLEM #1B ======== %
%===============================%
\item Question \#1B : Given the rough formulations governing power and frequency for each voltage region, discuss which region (consider Near and Super-threshold only) is more energy efficient. \\
\answer To start, we will make the following assumptions : \\
% $$\text{Given } k \in \mathbb{R}^+ : $$ 
 $ \text{Near-threshold voltage } = V_{nth} = k \text{, } \text{Super-threshold voltage } = V_{sth} = 2k : k \in \mathbb{R}^+ $ \\
 $ \text{Power} \propto V^3 \text{, Delay } \propto \frac{1}{V} \text{ , Energy } \propto \text{ Power } \times \text{ Delay} $ \\
 $ \text{Energy Efficiency } \propto \text{ Energy } \times \text{ Delay } = \text{ Power } \times \text{ Delay}^2 $ \\

 The energy efficiency can then be calculated for both the near and super threshold voltage levels, as shown below. 

 \begin{table}[H]
 \caption{Efficiency Calculations} \label{tab:effcalc} 
 \begin{center}
 \begin{tabular}{| c | l || l |}
 \hline Step  & Near-Threshold  & Super-Threshold \\ \hline
 1 & $P_{nth} = V_{nth}^3 = k^3$ & $P_sth = V_{sth}^3 = (2k)^3 = 8k$ \\[0.1in]
 2 & $D_{nth} = \frac{1}{V_{nth}} = \frac{1}{k}$ & $D_{sth} = \frac{1}{2k}$ \\[0.1in] 
 3 & $E_{nth} = P_{nth}*D_{nth} = \frac{k^3}{k} = {k}^2$ & $E_{sth} = P_{sth}*D_{sth} = \frac{8k^3}{2k} = {4k}^2$ \\[0.1in]
 4 &$EE_{nth} = E_{nth}*D_{nth} = \frac{k^2}{k} = k$ &  $EE_{sth} = E_{sth}*D_{sth} = \frac{4k^2}{2k} = 2k$ \\[0.1in] \hline
 \end{tabular}
\end{center}
 \end {table}
 
 Thus voltage levels that are near the threshold are more energy efficient. \\


\enu



%==============================%
% ======== PROBLEM #2 ======== %
%==============================%
\item Question \#2 Computing ISA's

 \begin{table}[H]
 \caption {Question \#2 Answers} \label{tab:question2} 
 \begin{center}
 \begin{tabular}{| c | c | c | c | c |} \hline
 Architecture & Bytes in Program & Bytes Fetched & Bytes Loaded & Bytes Stored \\ \hline 
 x86          &      13          &       89      &        40    &       40     \\ \hline
 MIPS         &      32          &       248     &        40    &       40    \\ \hline
 Stack ISA    &      24          &       195     &        20    &       20     \\ \hline
 \end{tabular}
 \end{center}
 \end {table}

 \benu 

%===============================%
% ======== PROBLEM #2A ======== %
%===============================%
 \item Question \#2A x86 CISC ISA \\ Fill out the first row of the above table (from the handout), but assume 32-bit data values. \\
  \answer  (See Table \#2, row \#1) \\
  \textbf{Exaplanation} - There are 13 bytes in the program, we know this by summing the 6 instructions by there byte count. 89 bytes fetches is determined by tracing the routine through 10 iterations plus the intitializing instructions. Bytes loaded and Bytes stored all come from the \texttt{inc(ra, rb, imm)} instruction, which loads and stores 4 bytes for each of the 10 calls. 


% 1 xor %eax, %eax                3
% 2 jmp L1                        2
% 3 loop: inc (%edx, %eax, 4)     3
% 4 inc %eax                      1
% 5 L1: cmp %ecx, %eax            2
% 6 jl loop                       2

%3, 2, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 
%0     0           1           2           3           4           5           6           7           8           9          10


%===============================%
% ======== PROBLEM #2B ======== %
%===============================%
 \item Question \#2B MIPS RISC ISA \\ Write the assembly code that would generate if the C code were compiled on a machine that uses the MIPS ISA. Fill out the second row of the above table. \\ \answer \\

 \texttt{r1} is the counter variable. \texttt{r2} contains the size variable (10). \texttt{r3} contains the address of the first item in the array.
 \begin{center}
   \begin{tabular}{l l  l}
      \texttt{}      & \texttt{subu r1, r1, r1}    & \texttt{ \# intialize counter to zero} \\
      \texttt{}      & \texttt{j CMPR}             & \texttt{ \# jump to comparison} \\
      \texttt{LOOP:} & \texttt{lw r4, r3}          & \texttt{ \# load current array value} \\
      \texttt{}      & \texttt{addiu r4, r4, \#1}  & \texttt{ \# increment current array value} \\
      \texttt{}      & \texttt{sw r4, r3}          & \texttt{ \# store the incremented value} \\
      \texttt{}      & \texttt{addiu r3, r3, \#4}  & \texttt{ \# move to the next index in the array} \\
      \texttt{}      & \texttt{addiu r1, r1, \#1}  & \texttt{ \# increment the counter} \\
      \texttt{CMPR:} & \texttt{bne r1, r2, \#-6}   & \texttt{ \# compare counter with size, loop again if =/=} \\
   \end{tabular}
 \end{center}

 \textbf{Explanation} - The secnod row table values were calculated as follows. There are 8 instructions in the program, consisting of a constant 4 bytes each, giving 32 total bytes. There are 6 instructions inside of the loop, which iterates 10 times, giving $6\times 4 \times 10$ bytes fetched for the loop, plus the 2 instructions before the loop. This totals 248 bytes fetched. 40 bytes are loaded and stored as is the same with the x86 code, 4 bytes for each iteration of the loop.


%===============================%
% ======== PROBLEM #2C ======== %
%===============================%
 \item  Question \#2C STACK ISA \\ Write the assembly code that would generate if the C code were compiled on a machine that uses this stack-based architecture. Assume that going into the code, that the top of stack contains size and the second entry in the stack contains aptr. Fill out the third row in the above table 
 \\ \answer \\

  % \begin{center}
   \begin{tabular}{l l  l}
      \texttt{}       & \texttt{goto CMPR}  & \texttt{ \# Compare counter at stack top} \\
      \texttt{LOOP:}  & \texttt{swap}       & \texttt{ \# put address at top of stack} \\
      \texttt{}       & \texttt{dup}        & \texttt{ \# dup the address so popm doesn't destroy it} \\
      \texttt{}       & \texttt{pushm}      & \texttt{ \# get array value at address on stack top} \\
      \texttt{}       & \texttt{pushi \#1}  & \texttt{ \# put 1 on stack} \\
      \texttt{}       & \texttt{add}        & \texttt{ \# increment array value} \\
      \texttt{}       & \texttt{popm}       & \texttt{ \# put inc'd value back at memory address} \\
      \texttt{}       & \texttt{pushi \#2}  & \texttt{ \# put 2 on stack} \\
      \texttt{}       & \texttt{add}        & \texttt{ \# increment the address by 2 bytes} \\
      \texttt{}       & \texttt{swap}       & \texttt{ \# put counter at the top, address at 2nd spot} \\
      \texttt{}       & \texttt{pushi \#-1} & \texttt{ \# put -1 on stack} \\
      \texttt{}       & \texttt{add}        & \texttt{ \# decrement the counter by 1} \\  
      \texttt{CMPR:}  & \texttt{bgtz LOOP}  & \texttt{ \# if counter not zero, loop again} \\   
   \end{tabular} \\
 % \end{center}

  \textbf{Explanation} - The third row table values were calculated as follows. There are 13 instructions in the program, summing up over their respective instruction lengths yields 24 bytes. Of these 24 bytes, 19 are inside of the loop, which iterates 10 times, which gives 190 bytes. Add in the 5 bytes to do this initial goto and you end up with 195 bytes fetched. The program performs 10 loads and 10 stores, each with 2 bytes, giving 20 bytes total load/stored.


%===============================%
% ======== PROBLEM #2D ======== %
%===============================%
 \item Question \#2D COMPARISON \\
 Compare the three ISAs studied with respect to static code size, number of instruction bytes fetched during execution, and memory traffic. Donâ€™t simply summarize the table but analyze what the numbers mean. \\ \answer \\

For static code size, it makes sense that the \texttt{x86 RISC ISA} had a smaller code size than \texttt{MIPS}, because they are both 32-bit but the \texttt{x86 ISA} has variable length instructions, meaning it doesn't need to waste 4 bytes for instructions that need less. It also had the fewest lines of code because each line could accomplish so much. Compare this to the \texttt{STACK ISA}, which was much longer because each instruction only does a little bit of work. The static code size between \texttt{MIPS ISA} and the \texttt{STACK ISA} seems like it could go either way, \texttt{MIPS} instructions do more work, but each instruction is twice as large as the \texttt{STACK ISA} instructions, so depending on the cmoplexity of the code it seems like either one could be bigger than the other. \par
 For the bytes fetched, this parallels the static code size in a way. Because each of these functions has to do 10 iterations plus some outside work, each of the bytes fetched will be roughly proportional to ten times the static code size. The \texttt{x86 ISA} fetched less than 10 times its static code size, because over $\frac{1}{3}$ of the bytes in the static code are outside of the loop, and thus are only executed once. The \texttt{MIPS ISA} and \texttt{STACK ISA} are a little closer to 10 times their static code size, because a larger proportion of the instructions are inside of the loop \par
 For memory traffic, all of these differents ISAs needed to do the same number of loads and stores, 10 each (one for each iteration). This means that the \texttt{MIPS ISA} and the \texttt{x86 ISA} loaded and stored the same number of bytes, because they both work on 32-bit data values. The \texttt{STACK ISA} only works on 16 bit values, so it only had half as much traffic from the data memory.


 \enu

 



%==============================%
% ======== PROBLEM #3 ======== %
%==============================%
\item Question \#3 DataPath \\ Write the control signal and wire values for the following instructions:

 \begin{table}[H]
 \caption {Question \#3A Answer Part 1} \label{tab:question3a} 
 \begin{center}
\begin{tabular}{| l | c | c | c | c | c | c | c | c | c | c | c |} \hline
 Instr  &   A   &   B   &            C                     &   D  &  E  &   F   &  G  &   H     &   I   &   J   &   K    \\ \hline
 Load   &  PC+1 &   PC  &   \texttt{ld \$r1, [\$r1-20]}    &  r1  &  x  &  -20  &  x  &  r1-20  &  r1-20 &  100  & 100   \\ \hline
 Store  &  PC+1 &   PC  &   \texttt{st [\$r2], \$r1   }    &  r2  & r1  &   0   & r1  &  r2+0   &  r2+0  &   x   &  x    \\ \hline
 Add    &  PC+1 &   PC  &   \texttt{add \$r1, \$r2, \$r3}  &  r1  & r2  &   0   & r2  &  r1+r2  &  r1+r2 &   x   & r1+r2 \\ \hline
 Jump   &       &       &   \texttt{jmp \#1000          }  &      &     &       &     &         &        &       &       \\ \hline
 \end{tabular}
 \end{center}
 \end {table}

 \begin{table}[H]
 \caption {Question \#3A Answers Part 2} \label{tab:question3a2} 
 \begin{center}
\begin{tabular}{| l | c | c | c | c | c | c | c | c |} \hline
 Instr  &   Rwe &   Rdst &   ALUinB &   ALUop &  DMWe &   Rwd &   JP  &   BR  \\ \hline
 Load   &    1  &    r2  &    F     &    ADD  &   0   &    J  &  PC+1 &  -16  \\ \hline
 Store  &    0  &    x   &    F     &    ADD  &   1   &    X  &  PC+1 &   4   \\ \hline
 Add    &    0  &    r3  &    E     &    ADD  &   0   &    I  &  PC+1 &   x   \\ \hline
 Jump   &       &        &          &         &       &       &       &       \\ \hline
 \end{tabular}
 \end{center}
 \end {table}
\benu

%===============================%
% ======== PROBLEM #3A ======== %
%===============================%
\item \texttt{ld \$r2, [\$r1-20]}

%===============================%
% ======== PROBLEM #3B ======== %
%===============================%
\item \texttt{st [\$r2], \$r1}


%===============================%
% ======== PROBLEM #3C ======== %
%===============================%
\item \texttt{add \$r1, \$r2, \$r3}


%===============================%
% ======== PROBLEM #3D ======== %
%===============================%
\item \texttt{jmp \#1000}

\enu

\enu

\end{document}