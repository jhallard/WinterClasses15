\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{url}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[margin=0.8in]{geometry}

% \setlength{\voffset}{-0.5in}
\setlength{\headsep}{5pt}
\newcommand{\suchthat}{\;\ifnum\currentgrouptype=16 \middle\fi|\;}
\newcommand{\answer}{\textbf{Answer : }}
\newcommand{\cd}{\texttt}
\newcommand{\benu}{\begin{enumerate}}
\newcommand{\enu}{\end{enumerate}}


%===========---------================
% Author John H Allard
% CMPE 110, HW #1
% December 10th, 2014
%===========---------================

\begin{document}
    % \vspace*{\stretch{-0.5}}
   \begin{center}
      \Large\textbf{CMPE 110 Homework \#1}\\
      \large\texttt{John Allard} \\
      \small\texttt{November 20th, 2014} \\
      \small\texttt{jhallard@ucsc.edu}
   \end{center}
   % \vspace*{\stretch{-0.5}}


\benu
% ======== PROBLEM #1 ======== %
\item Question \#1 - Power \\

\benu
\item Question \#1A : `...However, we discussed that nowadays power density and heat has become an issue preventing scaling of frequency. Discuss why power and temperature are becoming an issue'.
\answer  \\

\item Question \#1B : Given the rough formulations governing power and frequency for each voltage region, discuss which region (consider Near and Super-threshold only) is more energy efficient.
\answer \\
To start, we will make the following assumptions.
% $$\text{Given } k \in \mathbb{R}^+ : $$ 
 $$\text{Near-threshold voltage } = V_{nth} = k \text{, } \text{Super-threshold voltage } = V_{sth} = 2k : k \in \mathbb{R}^+ $$
 $$ \text{Power} \propto V^3 \text{, Delay } \propto \frac{1}{V} \text{ , Energy } \propto \text{ Power } \times \text{ Delay} $$
 $$ \text{Energy Efficiency } \propto \text{ Energy } \times \text{ Delay } = \text{ Power } \times \text{ Delay}^2 $$

 The energy efficiency can then be calculated for both the near and super threshold voltage levels, as shown below. 

 \begin{tabular}{l || r}
 Near-Threshold  & Super-Threshold \\ \hline \\
 $P_{nth} = V_{nth}^3 = k^3$ & $P_sth = V_{sth}^3 = (2k)^3 = 8k$ \\
 $D_{nth} = \frac{1}{V_{nth}} = \frac{1}{k}$ & $D_{sth} = \frac{1}{2k}$ \\ 
 $E_{nth} = P_{nth}*D_{nth} = \frac{k^3}{k} = {k}^2$ & $E_{sth} = P_{sth}*D_{sth} = \frac{8k^3}{2k} = {4k}^2$ \\
 $EE_{nth} = E_{nth}*D_{nth} = \frac{k^2}{k} = k$ &  $EE_{sth} = E_{sth}*D_{sth} = \frac{4k^2}{2k} = 2k$ \\
 \end{tabular}
 
 Thus voltage levels that are near the threshold are more energy efficient. \\

\enu


\item Question \#2 Computing ISA's

 \begin {table}[H]
 \caption {Question \#2 Answers} \label{tab:title} 
 \begin{center}
 \begin{tabular}{| c | c | c | c | c |} \hline
 Architecture & Bytes in Program & Bytes Fetched & Bytes Loaded & Bytes Stored \\ \hline 
 x86          &      13          &       89      &        40    &       40     \\ \hline
 MIPS         &                  &               &              &              \\ \hline
 Stack ISA    &                  &               &              &              \\ \hline
 \end{tabular}
 \end{center}
 \end {table}

 \textbf{Exaplanation} - There are 13 bytes in the program, we know this by summing the 6 instructions by there byte count. 89 bytes fetches is determined by tracing the routine through 10 iterations plus the intitializing instructions. Bytes loaded and Bytes stored all come from the \texttt{inc(ra, rb, imm)} instruction, which loads and stores 4 bytes for each of the 10 calls. 

 \benu 
 \item Question \#2A x86 CISC ISA \\ Fill out the first row of the above table (from the handout), but assume 32-bit data values.


% 1 xor %eax, %eax                3
% 2 jmp L1                        2
% 3 loop: inc (%edx, %eax, 4)     3
% 4 inc %eax                      1
% 5 L1: cmp %ecx, %eax            2
% 6 jl loop                       2

%3, 2, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 
%0     0           1           2           3           4           5           6           7           8           9          10
 \answer  (See Table \#1, row \#1)

 \item Write the assembly code that would generate if the C code were compiled on a machine that uses the MIPS ISA. Fill out the second row of the above table. \answer \\

 \texttt{r1} is the counter variable. \texttt{r2} contains the size variable (10). \texttt{r3} contains the address of the first item in the array.
 \begin{center}
   \begin{tabular}{l l  l}
      \texttt{} & \texttt{subu r1, r1, r1}    & \texttt{ \# intialize counter to zero} \\
      \texttt{} & \texttt{j COMPARE}          & \texttt{ \# jump to comparison} \\
      \texttt{loop : } & \texttt{lw r4, r3}   & \texttt{ \# load current array value} \\
      \texttt{} & \texttt{addiu r4, r4, \#1}   & \texttt{ \# increment current array value} \\
      \texttt{} & \texttt{addiu r4, r4, \#1}   & \texttt{ \# increment current array value} \\
   \end{tabular}
 \end{center}
 \enu


\item Provide the output for each of the following code statements. \\


\item For each of the following items, identify whether the caller fucntion or the callee function performs the actions.

\item TODO

\item Write a C program that computes the pig-latin translation of an english word. \\


\enu

\end{document}